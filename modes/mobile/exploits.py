"""
Exploit Modules for Mobile Application Security Testing.

This module provides various exploit techniques for identifying and exploiting
common vulnerabilities in mobile applications during security assessments.
"""
import asyncio
import base64
import hashlib
import json
import logging
import os
import re
import shutil
import subprocess
import tempfile
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple, Any, Callable, Awaitable, Union

import aiohttp
from androguard.core.bytecodes.apk import APK

from ..models import Finding, Severity, Platform
from .frida_manager import FridaScriptManager

logger = logging.getLogger(__name__)

class ExploitCategory(Enum):
    """Categories of exploits."""
    AUTH_BYPASS = "Authentication Bypass"
    DATA_EXPOSURE = "Data Exposure"
    CODE_EXECUTION = "Code Execution"
    PRIVILEGE_ESCALATION = "Privilege Escalation"
    CLIENT_SIDE = "Client-Side Attacks"
    SERVER_SIDE = "Server-Side Attacks"
    CRYPTO = "Cryptographic Issues"
    CONFIGURATION = "Misconfiguration"

@dataclass
class ExploitResult:
    """Result of an exploit attempt."""
    success: bool
    message: str
    data: Optional[Dict] = None
    findings: List[Finding] = field(default_factory=list)

class MobileExploiter:
    """Class for exploiting vulnerabilities in mobile applications."""
    
    def __init__(self, platform: Platform, package_name: str, frida_manager: FridaScriptManager = None):
        """Initialize the mobile exploiter.
        
        Args:
            platform: The target platform (Android/iOS).
            package_name: The package name or bundle ID of the target app.
            frida_manager: Optional FridaScriptManager instance for dynamic analysis.
        """
        self.platform = platform
        self.package_name = package_name
        self.frida_manager = frida_manager or FridaScriptManager()
        self.temp_dir = Path(tempfile.mkdtemp(prefix="vulnbuster_exploit_"))
        self.findings: List[Finding] = []
        self.session = None
    
    async def __aenter__(self):
        """Async context manager entry."""
        await self.frida_manager.connect()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit."""
        await self.cleanup()
    
    async def cleanup(self):
        """Clean up resources."""
        if hasattr(self, 'frida_manager'):
            await self.frida_manager.close()
        
        # Clean up temporary files
        try:
            if self.temp_dir.exists():
                shutil.rmtree(self.temp_dir)
        except Exception as e:
            logger.warning(f"Failed to clean up temporary directory: {e}")
    
    async def run_all_exploits(self) -> List[Finding]:
        """Run all available exploits against the target."""
        logger.info(f"Starting exploit suite against {self.package_name}")
        
        # Get all exploit methods
        exploit_methods = [
            method for name, method in self.__class__.__dict__.items()
            if name.startswith('exploit_') and callable(method)
        ]
        
        # Run all exploits
        results = []
        for method in exploit_methods:
            try:
                result = await method(self)
                results.append(result)
                
                if result.findings:
                    self.findings.extend(result.findings)
                
                logger.info(f"Exploit {method.__name__}: {result.message}")
                
            except Exception as e:
                logger.error(f"Error running exploit {method.__name__}: {str(e)}", exc_info=True)
        
        return self.findings
    
    # ===== Authentication Bypass Exploits =====
    
    async def exploit_auth_bypass_jwt_weak_secret(self) -> ExploitResult:
        """Exploit JWT with weak secret or none algorithm."""
        logger.info("Testing for JWT weak secret vulnerability...")
        
        # Common weak secrets to test
        weak_secrets = [
            "", "secret", "password", "admin", "123456", "qwerty",
            "letmein", "welcome", "123456789", "12345678", "12345"
        ]
        
        # Try to extract JWT from the app
        jwt_tokens = await self._extract_jwt_tokens()
        
        if not jwt_tokens:
            return ExploitResult(
                success=False,
                message="No JWT tokens found in the application",
                findings=[
                    Finding(
                        title="No JWT Tokens Found",
                        description="No JWT tokens were found during the scan.",
                        severity=Severity.INFO,
                        context={"exploit": "jwt_weak_secret"}
                    )
                ]
            )
        
        vulnerable_tokens = []
        
        for token in jwt_tokens:
            # Check for none algorithm vulnerability
            if self._check_jwt_none_algorithm(token):
                vulnerable_tokens.append({
                    "token": token,
                    "vulnerability": "none_algorithm",
                    "severity": "high"
                })
                continue
            
            # Check for weak secret
            for secret in weak_secrets:
                if self._check_jwt_secret(token, secret):
                    vulnerable_tokens.append({
                        "token": token,
                        "vulnerability": "weak_secret",
                        "secret": secret,
                        "severity": "critical"
                    })
                    break
        
        if vulnerable_tokens:
            return ExploitResult(
                success=True,
                message=f"Found {len(vulnerable_tokens)} vulnerable JWT tokens",
                data={"vulnerable_tokens": vulnerable_tokens},
                findings=[
                    Finding(
                        title="JWT Implementation Vulnerability",
                        description=(
                            f"Found {len(vulnerable_tokens)} JWT tokens with security issues. "
                            "Vulnerabilities include weak secrets and none algorithm."
                        ),
                        severity=Severity.HIGH,
                        context={
                            "exploit": "jwt_weak_secret",
                            "vulnerable_tokens": vulnerable_tokens,
                            "recommendation": (
                                "Use strong, random secrets for JWT signing. "
                                "Disable the 'none' algorithm. Use proper key management. "
                                "Set appropriate token expiration times."
                            )
                        }
                    )
                ]
            )
        
        return ExploitResult(
            success=False,
            message="No JWT vulnerabilities found",
            findings=[
                Finding(
                    title="JWT Implementation Secure",
                    description="No JWT implementation vulnerabilities were found.",
                    severity=Severity.INFO,
                    context={"exploit": "jwt_weak_secret"}
                )
            ]
        )
    
    async def exploit_auth_bypass_sql_injection(self) -> ExploitResult:
        """Exploit SQL injection in authentication."""
        logger.info("Testing for SQL injection in authentication...")
        
        # This is a placeholder for SQL injection testing logic
        # In a real implementation, this would involve:
        # 1. Identifying login endpoints
        # 2. Testing for SQLi using various payloads
        # 3. Analyzing responses for SQL errors or successful bypasses
        
        return ExploitResult(
            success=False,
            message="SQL injection test not implemented yet",
            findings=[]
        )
    
    # ===== Data Exposure Exploits =====
    
    async def exploit_data_exposure_logs(self) -> ExploitResult:
        """Exploit exposure of sensitive data in logs."""
        logger.info("Testing for sensitive data exposure in logs...")
        
        if self.platform == Platform.ANDROID:
            return await self._exploit_android_logs()
        elif self.platform == Platform.IOS:
            return await self._exploit_ios_logs()
        
        return ExploitResult(
            success=False,
            message="Log exposure test not supported for this platform",
            findings=[]
        )
    
    async def _exploit_android_logs(self) -> ExploitResult:
        """Extract and analyze logs on Android."""
        try:
            # Use logcat to get app logs
            process = await asyncio.create_subprocess_exec(
                "adb", "logcat", "-d", "-s", self.package_name,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode != 0:
                return ExploitResult(
                    success=False,
                    message=f"Failed to get logs: {stderr.decode().strip()}",
                    findings=[]
                )
            
            logs = stdout.decode()
            
            # Look for sensitive information in logs
            sensitive_patterns = {
                "password": r"(password|passwd|pwd|secret|token|api[_-]?key|auth|credential)\\s*[=:]+\\s*([^\\s&;'"]+)",
                "email": r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}",
                "credit_card": r"\\b(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11})\\b",
                "ssn": r"\\b\\d{3}[-.]?\\d{2}[-.]?\\d{4}\\b",
                "ip_address": r"\\b(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b"
            }
            
            findings = []
            exposed_data = {}
            
            for data_type, pattern in sensitive_patterns.items():
                matches = re.findall(pattern, logs, re.IGNORECASE)
                if matches:
                    exposed_data[data_type] = list(set(matches))  # Remove duplicates
            
            if exposed_data:
                finding = Finding(
                    title="Sensitive Data Exposure in Logs",
                    description=(
                        "The application logs contain sensitive information that could be accessed "
                        "by other applications or users with physical access to the device."
                    ),
                    severity=Severity.HIGH,
                    context={
                        "exploit": "data_exposure_logs",
                        "exposed_data_types": list(exposed_data.keys()),
                        "sample_data": {k: v[:3] for k, v in exposed_data.items()},  # Include first 3 samples
                        "recommendation": (
                            "Avoid logging sensitive information. Use ProGuard/R8 to remove logging "
                            "statements in release builds. Implement proper log levels and ensure "
                            "debug logging is disabled in production."
                        )
                    }
                )
                findings.append(finding)
                
                return ExploitResult(
                    success=True,
                    message=f"Found {len(exposed_data)} types of sensitive data in logs",
                    data={"exposed_data": exposed_data},
                    findings=findings
                )
            
            return ExploitResult(
                success=False,
                message="No sensitive data found in logs",
                findings=[
                    Finding(
                        title="No Sensitive Data in Logs",
                        description="No sensitive data was found in the application logs.",
                        severity=Severity.INFO,
                        context={"exploit": "data_exposure_logs"}
                    )
                ]
            )
            
        except Exception as e:
            return ExploitResult(
                success=False,
                message=f"Error analyzing logs: {str(e)}",
                findings=[]
            )
    
    async def _exploit_ios_logs(self) -> ExploitResult:
        """Extract and analyze logs on iOS."""
        # iOS log extraction would require a jailbroken device and different tools
        # This is a simplified example
        return ExploitResult(
            success=False,
            message="iOS log analysis requires a jailbroken device",
            findings=[]
        )
    
    # ===== Code Execution Exploits =====
    
    async def exploit_code_exec_deeplink(self) -> ExploitResult:
        """Exploit deeplink handling for code execution."""
        logger.info("Testing for deeplink code execution...")
        
        if self.platform == Platform.ANDROID:
            return await self._exploit_android_deeplink()
        elif self.platform == Platform.IOS:
            return await self._exploit_ios_universal_links()
        
        return ExploitResult(
            success=False,
            message="Deeplink test not supported for this platform",
            findings=[]
        )
    
    async def _exploit_android_deeplink(self) -> ExploitResult:
        """Test for deeplink vulnerabilities on Android."""
        try:
            # Extract deeplink information from the manifest
            apk_path = await self._get_apk_path()
            if not apk_path:
                return ExploitResult(
                    success=False,
                    message="Could not find APK for the specified package",
                    findings=[]
                )
            
            apk = APK(apk_path)
            deeplinks = []
            
            # Find activities with intent filters for deeplinks
            for activity in apk.get_activities():
                intent_filters = apk.get_intent_filters('activity', activity)
                if not intent_filters:
                    continue
                
                for intent_filter in intent_filters.values():
                    if 'android.intent.action.VIEW' in intent_filter.get('action', []):
                        schemes = set()
                        hosts = set()
                        paths = set()
                        
                        for scheme in intent_filter.get('dataScheme', []):
                            schemes.add(scheme)
                        
                        for host in intent_filter.get('dataHost', []):
                            hosts.add(host)
                        
                        for path in intent_filter.get('dataPath', []):
                            paths.add(path)
                        
                        if schemes:
                            deeplink_info = {
                                "activity": activity,
                                "schemes": list(schemes),
                                "hosts": list(hosts),
                                "paths": list(paths)
                            }
                            deeplinks.append(deeplink_info)
            
            if not deeplinks:
                return ExploitResult(
                    success=False,
                    message="No deeplinks found in the application",
                    findings=[
                        Finding(
                            title="No Deeplinks Found",
                            description="No deeplink handlers were found in the application.",
                            severity=Severity.INFO,
                            context={"exploit": "deeplink_code_exec"}
                        )
                    ]
                )
            
            # Test deeplinks for vulnerabilities
            vulnerable_deeplinks = []
            
            for deeplink in deeplinks:
                # Test for path traversal
                if self._test_deeplink_path_traversal(deeplink):
                    deeplink["vulnerability"] = "path_traversal"
                    vulnerable_deeplinks.append(deeplink)
                    continue
                
                # Test for XSS
                if self._test_deeplink_xss(deeplink):
                    deeplink["vulnerability"] = "xss"
                    vulnerable_deeplinks.append(deeplink)
                    continue
                
                # Test for local file inclusion
                if self._test_deeplink_lfi(deeplink):
                    deeplink["vulnerability"] = "local_file_inclusion"
                    vulnerable_deeplinks.append(deeplink)
            
            if vulnerable_deeplinks:
                return ExploitResult(
                    success=True,
                    message=f"Found {len(vulnerable_deeplinks)} vulnerable deeplinks",
                    data={"vulnerable_deeplinks": vulnerable_deeplinks},
                    findings=[
                        Finding(
                            title="Insecure Deeplink Handling",
                            description=(
                                f"Found {len(vulnerable_deeplinks)} deeplinks with security issues. "
                                "Vulnerabilities include path traversal, XSS, and local file inclusion."
                            ),
                            severity=Severity.HIGH,
                            context={
                                "exploit": "deeplink_code_exec",
                                "vulnerable_deeplinks": vulnerable_deeplinks,
                                "recommendation": (
                                    "Validate and sanitize all deeplink inputs. Use explicit intents "
                                    "when possible. Implement proper URI parsing and validation. "
                                    "Use WebView with appropriate security settings."
                                )
                            }
                        )
                    ]
                )
            
            return ExploitResult(
                success=False,
                message="No deeplink vulnerabilities found",
                findings=[
                    Finding(
                        title="Deeplink Handling Secure",
                        description="No deeplink vulnerabilities were found.",
                        severity=Severity.INFO,
                        context={"exploit": "deeplink_code_exec"}
                    )
                ]
            )
            
        except Exception as e:
            return ExploitResult(
                success=False,
                message=f"Error testing deeplinks: {str(e)}",
                findings=[]
            )
    
    # ===== Helper Methods =====
    
    async def _extract_jwt_tokens(self) -> List[str]:
        """Extract JWT tokens from the application."""
        # In a real implementation, this would extract JWT tokens from:
        # 1. Shared preferences
        # 2. Network traffic
        # 3. Logs
        # 4. Memory
        
        # For now, return an empty list as a placeholder
        return []
    
    def _check_jwt_none_algorithm(self, token: str) -> bool:
        """Check if a JWT token is using the 'none' algorithm."""
        try:
            header_encoded = token.split('.')[0]
            # Add padding if needed
            header_encoded += '=' * (-len(header_encoded) % 4)
            header = json.loads(base64.b64decode(header_encoded).decode('utf-8'))
            
            return header.get('alg', '').lower() == 'none'
        except:
            return False
    
    def _check_jwt_secret(self, token: str, secret: str) -> bool:
        """Check if a JWT token is signed with the given secret."""
        try:
            import jwt
            
            # Try to decode with the secret
            jwt.decode(token, secret, algorithms=['HS256', 'HS384', 'HS512'])
            return True
        except:
            return False
    
    async def _get_apk_path(self) -> Optional[str]:
        """Get the path to the APK for the target package."""
        if self.platform != Platform.ANDROID:
            return None
        
        try:
            # Try to find the APK on the device
            process = await asyncio.create_subprocess_exec(
                "adb", "shell", "pm", "path
