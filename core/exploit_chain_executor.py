import asyncio
from typing import List, Dict, Any

# --- Pattern-based Chain Detection ---
CHAIN_PATTERNS = [
    (['idor', 'upload'], 'IDOR+Upload→RCE'),
    (['lfi', 'log'], 'LFI+Logs→Shell'),
    (['sqli', 'file write'], 'SQLi+FileWrite→Webshell'),
    (['xss', 'csrf'], 'XSS+CSRF→Account Takeover'),
    # Add more as needed
]

def _normalize_finding(finding: Dict[str, Any]) -> str:
    t = finding.get('type', '').lower()
    desc = finding.get('description', '').lower()
    return t + ' ' + desc

async def detect_chains(findings: List[Dict[str, Any]]) -> List[str]:
    norm = [_normalize_finding(f) for f in findings]
    chains = []
    for pattern, label in CHAIN_PATTERNS:
        if all(any(p in n for n in norm) for p in pattern):
            chains.append(label)
    return chains

# --- Stub Execution Logic ---
async def execute_chain(chain: str, context: Any = None) -> str:
    # In real use, this would call the relevant modules in order
    await asyncio.sleep(0.2)
    return f"[executed] {chain} (stub)"

# --- AI Chain Reasoning Prompt ---
AI_CHAIN_PROMPT = (
    "You are an expert exploit developer. Given a list of findings, reason about possible exploit chains. "
    "Suggest the most impactful chain and explain why it is likely to succeed. "
    "Output only the chain and reasoning.\n"
    "Example: If IDOR and file upload are present, suggest chaining for RCE."
)

async def ai_chain_reasoning(findings: List[Dict[str, Any]]) -> str:
    # TODO: Integrate with Mixtral or LLM for chain reasoning
    # Use AI_CHAIN_PROMPT as the system/user prompt
    await asyncio.sleep(0.1)
    return f"[AI] Best exploit chain (prompt: {AI_CHAIN_PROMPT[:60]}...)" 